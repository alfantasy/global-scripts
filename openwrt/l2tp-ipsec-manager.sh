#!/bin/sh
# L2TP/IPSec tunnel management script for OpenWRT
# Logging to /var/log/l2tp-ipsec-restart.log

CONFIG_FILE="/etc/l2tp-ipsec-manager.conf"

# Default values as simple variables
DEFAULT_IPSEC_SERVICE="strongswan"
DEFAULT_IPSEC_DAEMON="charon"
DEFAULT_L2TP_SERVICE="xl2tpd"
DEFAULT_LOG_FILE="/var/log/l2tp-ipsec-restart.log"
DEFAULT_L2TP_TUNNEL="mytunnel"
DEFAULT_IPSEC_CONN="myconn"

create_config() {
    log_message "[I] Configuration file creating: $CONFIG_FILE"
    # Create directory for config if needed
    mkdir -p "$(dirname "$CONFIG_FILE")"

    # Create config with simple variable expansion
    cat > "$CONFIG_FILE" <<EOF
# L2TP/IPSec Manager Configuration 
# Auto-generated by l2tp-ipsec-manager.sh
# Generated on $(date '+%Y-%m-%d %H:%M:%S')

IPSEC_SERVICE=$DEFAULT_IPSEC_SERVICE
IPSEC_DAEMON=$DEFAULT_IPSEC_DAEMON
L2TP_SERVICE=$DEFAULT_L2TP_SERVICE
LOG_FILE=$DEFAULT_LOG_FILE
L2TP_TUNNEL=$DEFAULT_L2TP_TUNNEL
IPSEC_CONN=$DEFAULT_IPSEC_CONN
IP_SERVER="127.0.0.1"
EOF

    log_message "[I] Configuration file created: $CONFIG_FILE"
}

config_has_valid_content() {
    [ -f "$CONFIG_FILE" ] || return 1
    
    # Check if config contains at least one of our key variables
    if grep -q "^IPSEC_SERVICE=" "$CONFIG_FILE" || \
       grep -q "^L2TP_SERVICE=" "$CONFIG_FILE" || \
       grep -q "^L2TP_TUNNEL=" "$CONFIG_FILE"; then
        return 0
    else
        return 1
    fi
}

# Load configuration
load_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        create_config
    elif ! config_has_valid_content; then
        create_config
    fi

    # Load the configuration
    . "$CONFIG_FILE"
    
    # Set defaults for any missing variables
    : ${IPSEC_SERVICE:=$DEFAULT_IPSEC_SERVICE}
    : ${IPSEC_DAEMON:=$DEFAULT_IPSEC_DAEMON}
    : ${L2TP_SERVICE:=$DEFAULT_L2TP_SERVICE}
    : ${LOG_FILE:=$DEFAULT_LOG_FILE}
    : ${L2TP_TUNNEL:=$DEFAULT_L2TP_TUNNEL}
    : ${IPSEC_CONN:=$DEFAULT_IPSEC_CONN}
    : ${IP_SERVER:="127.0.0.1"}

    # Ensure log directory exists
    mkdir -p "$(dirname "$LOG_FILE")"
}

show_config() {
    log_message "Configuration shown below:"
    log_message "IPSEC_SERVICE=$IPSEC_SERVICE"
    log_message "IPSEC_DAEMON=$IPSEC_DAEMON" 
    log_message "L2TP_SERVICE=$L2TP_SERVICE"
    log_message "LOG_FILE=$LOG_FILE"
    log_message "L2TP_TUNNEL=$L2TP_TUNNEL"
    log_message "IPSEC_CONN=$IPSEC_CONN"
    log_message "IP_SERVER=$IP_SERVER"
}

# Logging function
log_message() {
    local TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$TIMESTAMP] $1" >> "$LOG_FILE"
    logger -t "l2tp-ipsec-manager" "$1"
}

# Dependency check function
check_dependencies() {
    for dep in "$IPSEC_SERVICE" "$L2TP_SERVICE"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            log_message "[ERROR] $dep not found"
            exit 1
        fi
    done
}

# Process finding and termination function
kill_services() {
    log_message "[I] Searching for running processes..."
    
    local our_pid=$$
    local parent_pid=$PPID
    
    # Find and kill xl2tpd
    XL2TPD_PID=$(ps | grep -v grep | grep "$L2TP_SERVICE" | awk '{print $1}')
    if [ -n "$XL2TPD_PID" ]; then
        # Проверяем что это не наш процесс и не родительский
        if [ "$XL2TPD_PID" -eq "$our_pid" ] || [ "$XL2TPD_PID" -eq "$parent_pid" ]; then
            log_message "[WARNING] Skipping our own process $L2TP_SERVICE (PID: $XL2TPD_PID)"
        else
            log_message "[I] Terminating $L2TP_SERVICE (PID: $XL2TPD_PID)"
            kill "$XL2TPD_PID" 2>/dev/null
            sleep 2
            # Force kill if needed
            if ps | grep -q "$XL2TPD_PID"; then
                kill -9 "$XL2TPD_PID" 2>/dev/null
                log_message "[WARNING] Force terminating $L2TP_SERVICE (PID: $XL2TPD_PID)"
            fi
            /etc/init.d/"$L2TP_SERVICE" stop
        fi
    fi

    # Find and kill IPSec daemons
    IPSEC_PIDS=$(ps | grep -v grep | grep -E "$IPSEC_DAEMON|$IPSEC_SERVICE|pluto" | awk '{print $1}')
    if [ -n "$IPSEC_PIDS" ]; then
        log_message "[I] Found IPSec processes (PIDs: $IPSEC_PIDS)"
        
        # Используем цикл вместо xargs с проверкой
        for pid in $IPSEC_PIDS; do
            # Пропускаем некорректные PID и наши собственные процессы
            [ "$pid" -eq "$pid" ] 2>/dev/null || continue
            [ "$pid" -eq "$our_pid" ] && continue
            [ "$pid" -eq "$parent_pid" ] && continue
            
            log_message "[I] Terminating IPSec process (PID: $pid)"
            kill "$pid" 2>/dev/null
        done
        sleep 3
        
        # Force kill remaining processes
        REMAINING_PIDS=$(ps | grep -v grep | grep -E "$IPSEC_DAEMON|$IPSEC_SERVICE|pluto" | awk '{print $1}')
        if [ -n "$REMAINING_PIDS" ]; then
            log_message "[I] Force killing remaining IPSec processes (PIDs: $REMAINING_PIDS)"
            for pid in $REMAINING_PIDS; do
                [ "$pid" -eq "$pid" ] 2>/dev/null || continue
                [ "$pid" -eq "$our_pid" ] && continue
                [ "$pid" -eq "$parent_pid" ] && continue
                
                kill -9 "$pid" 2>/dev/null
            done
        fi
    fi
    
    sleep 2

    # Additional interface and session cleanup
    if command -v "$IPSEC_SERVICE" >/dev/null 2>&1; then
        "$IPSEC_SERVICE" stop 2>/dev/null
        sleep 2
    fi
    log_message "[I] Cleanup completed"
}

# Service startup function
start_services() {
    log_message "[I] Starting services..."
    
    # Start StrongSwan
    if "$IPSEC_SERVICE" start 2>/dev/null; then
        log_message "[I] $IPSEC_SERVICE started"
    else
        log_message "[ERROR] Failed to start $IPSEC_SERVICE"
        return 1
    fi
    
    sleep 2

    # Start xl2tpd
    if "/etc/init.d/$L2TP_SERVICE" start 2>/dev/null & then
        log_message "[I] $L2TP_SERVICE started"
    else
        log_message "[ERROR] Failed to start $L2TP_SERVICE"
        return 1
    fi
    
    sleep 2
    
    if command -v "$IPSEC_SERVICE" >/dev/null 2>&1; then
        if "$IPSEC_SERVICE" up "$IPSEC_CONN" 2>/dev/null; then
            log_message "[I] IPSec connection «$IPSEC_CONN» started"
        else
            log_message "[ERROR] Failed to start IPSec connection «$IPSEC_CONN»"
            return 1
        fi
    fi

    sleep 5

    # Tunnel initialization (if needed)
    if [ -p "/var/run/$L2TP_SERVICE/l2tp-control" ]; then
        echo "c $L2TP_TUNNEL" > "/var/run/$L2TP_SERVICE/l2tp-control" 2>/dev/null
        log_message "[I] L2TP tunnel «$L2TP_TUNNEL» initialization command sent"
    fi
}

fix_routing() {
    log_message "[I] Fixing routing to prevent recursion..."
    local default_route=$(ip route show default 2>/dev/null | head -1)

    if [ -z "$default_route" ]; then
        log_message "[ERROR] Default route not found"
        return 1
    fi

    # Enable IP forwarding
    echo "1" > /proc/sys/net/ipv4/ip_forward

    local main_gateway=$(echo "$default_route" | awk '{print $3}')
    local main_interface=$(echo "$default_route" | awk '{print $5}')
    local main_ip=$(ip addr show dev "$main_interface" 2>/dev/null | grep "inet " | awk '{print $2}' | cut -d/ -f1 | head -1)

    log_message "[I] Detected: main gateway: $main_gateway, main interface: $main_interface, main IP: $main_ip"

    if "$IP_SERVER" == "127.0.0.1"; then
        log_message "[I] Skipping route to $IP_SERVER"
        return 0
    fi

    # Add route
    if ip route add "$IP_SERVER/32" via "$main_gateway" dev "$main_interface" 2>/dev/null; then
        log_message "[I] Route to $IP_SERVER added"
    else
        log_message "[ERROR] Failed to add route to $IP_SERVER"
        ip route add "$IP_SERVER/32" via "$main_gateway" dev "$main_interface"
        if ip route replace "$IP_SERVER/32" via "$main_gateway" dev "$main_interface" 2> /dev/null; then
            log_message "[I] Route to $IP_SERVER replaced"
        else
            log_message "[ERROR] Failed to replace route to $IP_SERVER"
            ip route replace "$IP_SERVER/32" via "$main_gateway" dev "$main_interface"
            ip route del "$IP_SERVER/32" via "$main_gateway" dev "$main_interface"
            return 1
        fi
    fi
}

# Status check function
check_status() {
    log_message "[I] Checking service status..."
    
    # Check IPSec starter
    if ps | grep -v grep | grep -q -E "$IPSEC_DAEMON|$IPSEC_SERVICE|pluto"; then
        log_message "[I] IPSec is running"
    else
        log_message "[WARNING] IPSec is NOT running"
        return 1
    fi
    
    # Check xl2tpd
    if ps | grep -v grep | grep -q "$L2TP_SERVICE"; then
        log_message "[I] $L2TP_SERVICE is running"
    else
        log_message "[WARNING] $L2TP_SERVICE is NOT running"
        return 1
    fi
    
    # Check tunnel (optional)
    if ip addr show | grep -q ppp; then
        log_message "[I] PPP interface detected"
    else
        log_message "[WARNING] PPP interface NOT detected"
    fi
}

## Main function
main() {    
    trap 'log_message "[WARNING] Received SIGTERM, exiting"' TERM
    load_config

    log_message "=== Starting L2TP/IPSec Manager ==="

    show_config

    # Check dependencies
    check_dependencies
    
    # Stop services
    kill_services
    sleep 5
    
    # Start services
    if start_services; then
        sleep 5
        if check_status; then
            log_message "[SUCCESS] Procedure start/restart completed successfully"
            fix_routing
            log_message "=== End of L2TP/IPSec Manager ==="
            exit 0
        else
            log_message "[WARNING] Procedure start/restart completed with errors"
            log_message "=== End of L2TP/IPSec Manager ==="
            exit 1
        fi
    else
        log_message "[ERROR] Procedure start/restart FAILED with errors"
        log_message "=== End of L2TP/IPSec Manager ==="
        exit 1
    fi
}

# Call main function
main "$@"